var searchIndex = {};
searchIndex["main"] = {"doc":"","items":[],"paths":[]};
searchIndex["pest"] = {"doc":"pest. Elegant, efficient grammars","items":[[3,"StringInput","pest","A `struct` useful for matching in-memory `String`s.",null,null],[3,"Token","","A `struct` representing tokens generated by a parser.",null,null],[12,"rule","","matched `Rule`",0,null],[12,"start","","starting position in `Input`",0,null],[12,"end","","ending position in `Input`",0,null],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"token"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"hash","","",0,null],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"token"}],"output":{"name":"bool"}}],[11,"ne","","",0,{"inputs":[{"name":"self"},{"name":"token"}],"output":{"name":"bool"}}],[11,"new","","Creates a new `Token`.",0,{"inputs":[{"name":"rule"},{"name":"usize"},{"name":"usize"}],"output":{"name":"token"}}],[11,"new","","Creates a new `StringInput` from a `&str`.",1,{"inputs":[{"name":"str"}],"output":{"name":"stringinput"}}],[11,"len","","",1,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"is_empty","","",1,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"pos","","",1,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"set_pos","","",1,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"slice","","",1,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"}],"output":{"name":"str"}}],[11,"line_col","","",1,null],[11,"match_string","","",1,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"bool"}}],[11,"match_insensitive","","",1,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"bool"}}],[11,"match_range","","",1,{"inputs":[{"name":"self"},{"name":"char"},{"name":"char"}],"output":{"name":"bool"}}],[0,"prelude","","A `mod` that contains `pest::Input`, `pest::Parser`, `pest::StringInput`, and `pest::Token`.",null,null],[3,"StringInput","pest::prelude","A `struct` useful for matching in-memory `String`s.",null,null],[3,"Token","","A `struct` representing tokens generated by a parser.",null,null],[12,"rule","","matched `Rule`",0,null],[12,"start","","starting position in `Input`",0,null],[12,"end","","ending position in `Input`",0,null],[8,"Input","","A `trait` that defines an input for a `Parser`.",null,null],[10,"len","","Returns length of an `Input`.",2,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[10,"is_empty","","Returns whether an `Input` is empty.",2,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"pos","","Returns current position of an `Input`.",2,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[10,"set_pos","","Set current position of an `Input`.",2,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[10,"slice","","Slices an `Input`.",2,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"}],"output":{"name":"str"}}],[10,"line_col","","Returns the line and column of a position for an `Input`.",2,null],[10,"match_string","","Matches `string` to an `Input`, returns whether it matched, and advances the position with `string.len()` in case it did.",2,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"bool"}}],[10,"match_insensitive","","Matches `string` to an `Input` case insensitively, returns whether it matched, and advances the position with `string.len()` in case it did.",2,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"bool"}}],[10,"match_range","","Matches if an `Input`'s current `char` is between `left` and `right`, and advances the position with one `char` in case it did.",2,{"inputs":[{"name":"self"},{"name":"char"},{"name":"char"}],"output":{"name":"bool"}}],[8,"Parser","","A `trait` that defines a parser.",null,null],[16,"Rule","","",3,null],[16,"Token","","",3,null],[10,"input","","",3,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[10,"input_mut","","",3,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[10,"end","","Returns whether a `Parser` has reached its end.",3,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"eoi_matched","","Returns whether a `Parser` has matched end-of-input.",3,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"reset","","Reset a `Parser`.",3,{"inputs":[{"name":"self"}],"output":null}],[10,"queue","","Returns the queue of all matched `Token`s.",3,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[10,"queue_mut","","Returns the mutable queue of all matched `Token`s.",3,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[10,"queue_with_captures","","Returns the queue of all matched `(Token, value)`s.",3,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[10,"queue_index","","Returns the current index within the queue. Used in `process!`.",3,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[10,"inc_queue_index","","Increments the current index within the queue. Used in `process!`.",3,{"inputs":[{"name":"self"}],"output":null}],[10,"set_queue_index","","Set the current index within the queue. Used in `process!`.",3,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[10,"skip","","Skips whitespace and comments.",3,{"inputs":[{"name":"self"}],"output":null}],[10,"is_atomic","","Returns whether a `Parser` is currently inside an atomic rule.",3,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"set_atomic","","Sets a `Parser` to atomic rule mode, barring comment & white-space skipping.",3,{"inputs":[{"name":"self"},{"name":"bool"}],"output":null}],[10,"track","","Keeps track of rule failures. It gets called when a `Rule` fails at `pos`.",3,null],[10,"tracked_len_pos","","Returns the length of the tracked `Rule`s.",3,null],[10,"expected","","Retuns a `Vec` of all expected `Rule`s at the deepest position where the parsing last stopped. It only returns leafs from the rule tree. Used for error reporting.",3,null],[10,"stack","","Returns the stack `Vec`.",3,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[10,"stack_mut","","Returns the mutable stack `Vec`.",3,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[8,"Input","pest","A `trait` that defines an input for a `Parser`.",null,null],[10,"len","","Returns length of an `Input`.",2,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[10,"is_empty","","Returns whether an `Input` is empty.",2,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"pos","","Returns current position of an `Input`.",2,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[10,"set_pos","","Set current position of an `Input`.",2,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[10,"slice","","Slices an `Input`.",2,{"inputs":[{"name":"self"},{"name":"usize"},{"name":"usize"}],"output":{"name":"str"}}],[10,"line_col","","Returns the line and column of a position for an `Input`.",2,null],[10,"match_string","","Matches `string` to an `Input`, returns whether it matched, and advances the position with `string.len()` in case it did.",2,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"bool"}}],[10,"match_insensitive","","Matches `string` to an `Input` case insensitively, returns whether it matched, and advances the position with `string.len()` in case it did.",2,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"bool"}}],[10,"match_range","","Matches if an `Input`'s current `char` is between `left` and `right`, and advances the position with one `char` in case it did.",2,{"inputs":[{"name":"self"},{"name":"char"},{"name":"char"}],"output":{"name":"bool"}}],[8,"Parser","","A `trait` that defines a parser.",null,null],[16,"Rule","","",3,null],[16,"Token","","",3,null],[10,"input","","",3,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[10,"input_mut","","",3,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[10,"end","","Returns whether a `Parser` has reached its end.",3,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"eoi_matched","","Returns whether a `Parser` has matched end-of-input.",3,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"reset","","Reset a `Parser`.",3,{"inputs":[{"name":"self"}],"output":null}],[10,"queue","","Returns the queue of all matched `Token`s.",3,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[10,"queue_mut","","Returns the mutable queue of all matched `Token`s.",3,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[10,"queue_with_captures","","Returns the queue of all matched `(Token, value)`s.",3,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[10,"queue_index","","Returns the current index within the queue. Used in `process!`.",3,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[10,"inc_queue_index","","Increments the current index within the queue. Used in `process!`.",3,{"inputs":[{"name":"self"}],"output":null}],[10,"set_queue_index","","Set the current index within the queue. Used in `process!`.",3,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[10,"skip","","Skips whitespace and comments.",3,{"inputs":[{"name":"self"}],"output":null}],[10,"is_atomic","","Returns whether a `Parser` is currently inside an atomic rule.",3,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"set_atomic","","Sets a `Parser` to atomic rule mode, barring comment & white-space skipping.",3,{"inputs":[{"name":"self"},{"name":"bool"}],"output":null}],[10,"track","","Keeps track of rule failures. It gets called when a `Rule` fails at `pos`.",3,null],[10,"tracked_len_pos","","Returns the length of the tracked `Rule`s.",3,null],[10,"expected","","Retuns a `Vec` of all expected `Rule`s at the deepest position where the parsing last stopped. It only returns leafs from the rule tree. Used for error reporting.",3,null],[10,"stack","","Returns the stack `Vec`.",3,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[10,"stack_mut","","Returns the mutable stack `Vec`.",3,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[14,"grammar","","A `macro` that defines each rule as a method on a `Parser` which parses from the current position. Rules are always defined between braces, with an optional symbol marking the type of rule defined.",null,null],[14,"process","","A `macro` for pattern-matching queued `Token`s generated by a `Parser`. It generates a method `process` on `&self` that processes the whole queue of `Token`s, reducing it to one single result.",null,null],[14,"impl_rdp","","A `macro` useful for implementing the `Parser` `trait` as a recursive descent parser. It only accepts `grammar!` and `process!` calls that get implemented on `self`.",null,null]],"paths":[[3,"Token"],[3,"StringInput"],[8,"Input"],[8,"Parser"]]};
searchIndex["tsqlust"] = {"doc":"","items":[[3,"Rdp","tsqlust","",null,null],[4,"Rule","","",null,null],[13,"any","","",0,null],[13,"soi","","",0,null],[13,"eoi","","",0,null],[13,"column_name_list","","",0,null],[13,"clause_where","","",0,null],[13,"pred_cmp","","",0,null],[13,"kw_not","","",0,null],[13,"kw_and","","",0,null],[13,"kw_or","","",0,null],[13,"kw_create_table","","",0,null],[13,"kw_with_ties","","",0,null],[13,"kw_percent","","",0,null],[13,"kw_where","","",0,null],[13,"kw_from","","",0,null],[13,"kw_top","","",0,null],[13,"kw_select","","",0,null],[13,"op_cmp_gt_eq","","",0,null],[13,"op_cmp_lt_eq","","",0,null],[13,"op_cmp_gt","","",0,null],[13,"op_cmp_lt","","",0,null],[13,"op_cmp_neq_bang","","",0,null],[13,"op_cmp_eq","","",0,null],[13,"op_cmp","","",0,null],[13,"tok_angle_close","","",0,null],[13,"tok_angle_open","","",0,null],[13,"tok_bang","","",0,null],[13,"tok_eq","","",0,null],[13,"tok_comma","","",0,null],[13,"tok_paren_close","","",0,null],[13,"tok_paren_open","","",0,null],[13,"tok_slash_forward","","",0,null],[13,"tok_star","","",0,null],[13,"tok_caret","","",0,null],[13,"tok_pipe","","",0,null],[13,"tok_percent","","",0,null],[13,"tok_ampersand","","",0,null],[13,"tok_minus","","",0,null],[13,"tok_plus","","",0,null],[13,"identifier","","",0,null],[13,"literal","","",0,null],[13,"lit_integer","","",0,null],[13,"lit_bool","","",0,null],[13,"expr","","",0,null],[13,"stmt_create_table","","",0,null],[13,"stmt_select","","",0,null],[13,"stmt_top","","",0,null],[13,"stmt_top_legacy","","",0,null],[5,"get_diagnostics_for_tsql","","This is a helper function so that example code can be written. You should not rely on it or expect it to exist in any following versions.",null,{"inputs":[{"name":"str"},{"name":"visitor"}],"output":{"name":"result"}}],[5,"parse_tsql_select","","This is a temporary function used by the WIP graphical interface. You should not rely on it or expect it to exist in any following versions.",null,{"inputs":[{"name":"str"}],"output":{"name":"result"}}],[0,"ast","","",null,null],[3,"Position","tsqlust::ast","",null,null],[12,"line","","",1,null],[12,"col","","",1,null],[3,"Node","","",null,null],[12,"pos","","Position in the AST",2,null],[12,"tnode","","The actual node in the tree.",2,null],[3,"SelectStatement","","A `SELECT` statement",null,null],[12,"top_statement","","",3,null],[12,"column_name_list","","",3,null],[12,"table_identifier","","",3,null],[3,"Identifier","","A table or column name",null,null],[12,"value","","",4,null],[3,"TopStatement","","A `TOP` statement",null,null],[12,"top_keyword","","",5,null],[12,"expr","","",5,null],[12,"paren_open","","",5,null],[12,"paren_close","","",5,null],[3,"ColumnNameList","","",null,null],[12,"identifiers","","",6,null],[3,"CreateTableStatement","","",null,null],[12,"table_identifier","","",7,null],[4,"Literal","","Represents a literal value (not a variable) found in the query source.",null,null],[13,"Bool","","",8,null],[13,"Int","","",8,null],[13,"Float","","",8,null],[13,"Str","","",8,null],[4,"Expression","","",null,null],[13,"Literal","","",9,null],[12,"lit","tsqlust::ast::Expression","",9,null],[4,"Keyword","tsqlust::ast","",null,null],[13,"Top","","",10,null],[4,"Token","","",null,null],[13,"ParenOpen","","",11,null],[13,"ParenClose","","",11,null],[11,"eq","","",1,{"inputs":[{"name":"self"},{"name":"position"}],"output":{"name":"bool"}}],[11,"ne","","",1,{"inputs":[{"name":"self"},{"name":"position"}],"output":{"name":"bool"}}],[11,"clone","","",1,{"inputs":[{"name":"self"}],"output":{"name":"position"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"to_pair","","Creates a tuple containing `line, col`.",1,null],[11,"default","","",1,{"inputs":[],"output":{"name":"position"}}],[11,"from","","",1,null],[11,"eq","","",2,{"inputs":[{"name":"self"},{"name":"node"}],"output":{"name":"bool"}}],[11,"ne","","",2,{"inputs":[{"name":"self"},{"name":"node"}],"output":{"name":"bool"}}],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",3,{"inputs":[{"name":"self"},{"name":"selectstatement"}],"output":{"name":"bool"}}],[11,"ne","","",3,{"inputs":[{"name":"self"},{"name":"selectstatement"}],"output":{"name":"bool"}}],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",8,{"inputs":[{"name":"self"},{"name":"literal"}],"output":{"name":"bool"}}],[11,"ne","","",8,{"inputs":[{"name":"self"},{"name":"literal"}],"output":{"name":"bool"}}],[11,"fmt","","",8,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",4,{"inputs":[{"name":"self"},{"name":"identifier"}],"output":{"name":"bool"}}],[11,"ne","","",4,{"inputs":[{"name":"self"},{"name":"identifier"}],"output":{"name":"bool"}}],[11,"fmt","","",4,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",9,{"inputs":[{"name":"self"},{"name":"expression"}],"output":{"name":"bool"}}],[11,"ne","","",9,{"inputs":[{"name":"self"},{"name":"expression"}],"output":{"name":"bool"}}],[11,"fmt","","",9,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",10,{"inputs":[{"name":"self"},{"name":"keyword"}],"output":{"name":"bool"}}],[11,"fmt","","",10,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",11,{"inputs":[{"name":"self"},{"name":"token"}],"output":{"name":"bool"}}],[11,"fmt","","",11,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",5,{"inputs":[{"name":"self"},{"name":"topstatement"}],"output":{"name":"bool"}}],[11,"ne","","",5,{"inputs":[{"name":"self"},{"name":"topstatement"}],"output":{"name":"bool"}}],[11,"fmt","","",5,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"is_legacy","","Indicates whether or not this is a legacy statement.",5,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"eq","","",6,{"inputs":[{"name":"self"},{"name":"columnnamelist"}],"output":{"name":"bool"}}],[11,"ne","","",6,{"inputs":[{"name":"self"},{"name":"columnnamelist"}],"output":{"name":"bool"}}],[11,"fmt","","",6,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",7,{"inputs":[{"name":"self"},{"name":"createtablestatement"}],"output":{"name":"bool"}}],[11,"ne","","",7,{"inputs":[{"name":"self"},{"name":"createtablestatement"}],"output":{"name":"bool"}}],[11,"fmt","","",7,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[0,"visitor","tsqlust","src/visitor/mod.rs",null,null],[8,"Visitor","tsqlust::visitor","The trait that allows walking an AST.",null,null],[11,"visit_select_statement","","",12,{"inputs":[{"name":"self"},{"name":"context"},{"name":"node"}],"output":null}],[11,"visit_top_statement","","",12,{"inputs":[{"name":"self"},{"name":"context"},{"name":"node"}],"output":null}],[11,"visit_column_name_list","","",12,{"inputs":[{"name":"self"},{"name":"context"},{"name":"node"}],"output":null}],[0,"diagnostics","tsqlust","",null,null],[3,"Context","tsqlust::diagnostics","Contains diagnostics recorded while walking an AST with a struct that implements `Visitor`.",null,null],[3,"Diagnostic","","Information recorded while walking an AST.",null,null],[12,"pos","","",13,null],[12,"code","","",13,null],[12,"message","","",13,null],[11,"new","","",14,{"inputs":[],"output":{"name":"context"}}],[11,"get_diagnostics","","",14,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[11,"add_diagnostic","","",14,{"inputs":[{"name":"self"},{"name":"diagnostic"}],"output":null}],[11,"fmt","","",13,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",13,{"inputs":[{"name":"self"},{"name":"diagnostic"}],"output":{"name":"bool"}}],[11,"ne","","",13,{"inputs":[{"name":"self"},{"name":"diagnostic"}],"output":{"name":"bool"}}],[11,"clone","tsqlust","",0,{"inputs":[{"name":"self"}],"output":{"name":"rule"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"hash","","",0,null],[11,"cmp","","",0,{"inputs":[{"name":"self"},{"name":"rule"}],"output":{"name":"ordering"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"rule"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",0,{"inputs":[{"name":"self"},{"name":"rule"}],"output":{"name":"option"}}],[11,"new","","",15,{"inputs":[{"name":"t"}],"output":{"name":"rdp"}}],[11,"comment","","",15,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"any","","",15,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"soi","","",15,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"eoi","","",15,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"tsql","","",15,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"stmt_top_legacy","","",15,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"stmt_top","","",15,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"stmt_select","","",15,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"stmt_create_table","","",15,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"top_level_repl","","",15,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"expr","","",15,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"lit_bool","","",15,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"lit_integer","","",15,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"literal","","",15,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"identifier","","",15,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"tok_plus","","",15,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"tok_minus","","",15,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"tok_ampersand","","",15,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"tok_percent","","",15,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"tok_pipe","","",15,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"tok_caret","","",15,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"tok_star","","",15,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"tok_slash_forward","","",15,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"tok_paren_open","","",15,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"tok_paren_close","","",15,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"tok_comma","","",15,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"tok_eq","","",15,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"tok_bang","","",15,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"tok_angle_open","","",15,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"tok_angle_close","","",15,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"op_cmp","","",15,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"op_cmp_eq","","",15,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"op_cmp_neq_bang","","",15,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"op_cmp_lt","","",15,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"op_cmp_gt","","",15,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"op_cmp_lt_eq","","",15,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"op_cmp_gt_eq","","",15,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"kw_select","","",15,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"kw_top","","",15,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"kw_from","","",15,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"kw_where","","",15,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"kw_percent","","",15,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"kw_with_ties","","",15,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"kw_create_table","","",15,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"kw_or","","",15,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"kw_and","","",15,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"kw_not","","",15,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"pred_cmp","","",15,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"clause_where","","",15,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"column_name_list","","",15,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"whitespace","","",15,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"try","","",15,{"inputs":[{"name":"self"},{"name":"bool"},{"name":"f"}],"output":{"name":"bool"}}],[11,"prec_climb","","",15,null],[11,"parse_stmt_top","","",15,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"parse_stmt_create_table","","",15,{"inputs":[{"name":"self"}],"output":{"name":"node"}}],[11,"parse_identifier","","",15,{"inputs":[{"name":"self"}],"output":{"name":"node"}}],[11,"parse_column_name_list","","",15,{"inputs":[{"name":"self"}],"output":{"name":"node"}}],[11,"parse_expression","","",15,{"inputs":[{"name":"self"}],"output":{"name":"node"}}],[11,"parse_literal","","",15,{"inputs":[{"name":"self"}],"output":{"name":"literal"}}],[11,"parse_stmt_select","","",15,{"inputs":[{"name":"self"}],"output":{"name":"node"}}],[11,"input","","",15,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"input_mut","","",15,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"end","","",15,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"eoi_matched","","",15,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"reset","","",15,{"inputs":[{"name":"self"}],"output":null}],[11,"queue","","",15,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[11,"queue_mut","","",15,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[11,"queue_with_captures","","",15,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[11,"queue_index","","",15,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"inc_queue_index","","",15,{"inputs":[{"name":"self"}],"output":null}],[11,"set_queue_index","","",15,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"skip","","",15,{"inputs":[{"name":"self"}],"output":null}],[11,"is_atomic","","",15,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"set_atomic","","",15,{"inputs":[{"name":"self"},{"name":"bool"}],"output":null}],[11,"track","","",15,{"inputs":[{"name":"self"},{"name":"rule"},{"name":"usize"}],"output":null}],[11,"tracked_len_pos","","",15,null],[11,"expected","","",15,null],[11,"stack","","",15,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[11,"stack_mut","","",15,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}]],"paths":[[4,"Rule"],[3,"Position"],[3,"Node"],[3,"SelectStatement"],[3,"Identifier"],[3,"TopStatement"],[3,"ColumnNameList"],[3,"CreateTableStatement"],[4,"Literal"],[4,"Expression"],[4,"Keyword"],[4,"Token"],[8,"Visitor"],[3,"Diagnostic"],[3,"Context"],[3,"Rdp"]]};
initSearch(searchIndex);
